<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script>
        /**
         * 函数参数的默认值
         */
        /*
         * ES6允许为函数的参数设置默认值，即直接卸载参数定义的后面。
         */

        /**
         * 好处
         */
        /*
         * 1，代码简洁
         * 2，阅读代码的人可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档。
         * 3，有利于将来的代码优化，及时未来版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。
         */

        /**
         * 注意
         */
        /*
         * 1，参数变量是默认声明的，所以不能使用let、const再次声明
         *    function foo(x = 5) {
         *       let x = 1;// error
         *       const x = 2;// error
         *    }
         * 2，使用参数默认值时，函数不能有同名参数
         *    function foo(x, x, y) {//不报错
         *    }
         *    function foo(x, x, y = 1) {//报错
         *    }
         * 3，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。
         *    let x = 99;
         *    function foo(p = x + 1) {
         *        console.log(p);
         *    }
         *    foo();//100
         *    x = 100;
         *    foo();//101
         */
    </script>
    <script>
        /* ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。*/
        //下面的代码检查函数log的参数y有没有赋值，若没有，则指定默认值为world。
        function log(x, y) {
            y = y || 'world';
            console.log(x, y)
        }
        log('Hello');//Hello world
        log('Hello', 'cherry');//Hello cherry
        //这种写法的缺点是：若参数y赋值了，但是对应的布尔值为false，则该赋值不起作用，显示的是默认值
        log('Hello', '');//Hello world
        log('Hello', 0);//Hello world
        log('Hello', undefined);//Hello world
        log('Hello', null);//Hello world
        log('Hello', false);//Hello world
        //为避免这个问题，通常需要先判断一下参数是否被赋值,若没有,在等于默认值。
        if (typeof y === 'undefined') {
            y = 'world';
        }

        /* ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。*/
        function log(x, y = 'world') {
            console.log(x, y)
        }
        log('Hello');//Hello world
        log('Hello', 'cherry');//Hello cherry
        log('Hello', '');//Hello
    </script>
</head>
<body>

</body>
</html>